{"name":"Harden","body":"> Your domain model is weak. It's a pansy. It needs to be *Hardened*.\r\n\r\nHarden takes your objects and wraps them in a super hard layer, preventing code from being called when it's not meant to be called, in ways it's not meant to be called.\r\n\r\nHeres an example of a class ready to be hardened:\r\n\r\n    public class User\r\n    {\r\n        public virtual void Ban() { ... } //virtual so we can proxy it\r\n\r\n        public bool AllowBan()\r\n        {\r\n            return Context.CurrentUser.IsAdmin; //only admins can Ban users\r\n        }\r\n        \r\n        public virtual string Email { get; set; }\r\n\r\n        public bool AllowEmail()\r\n        {\r\n            return Context.CurrentUser.IsAdmin || Context.CurrentUser == this;\r\n            //only admins can see or change other peoples emails\r\n        }                \r\n    }\r\n\r\nNow we harden it:\r\n\r\n    var user = Hardener.Harden(user);\r\n    user.Ban; //You better be an admin, or you just got yourself a HardenException\r\n\r\n\r\nThe Why\r\n-------\r\n\r\nSome of you might be asking why you need this. After all, the only people who can access against your model are you and other developers at your company...\r\n\r\nSTOP. RIGHT. THERE.\r\n\r\nLike it or not, objects end up with internal state machines, with methods that should be called in certain ways.\r\nWhether it's someone else at your company, someone who used to work there or someone who will, at some point your objects are going to be misused, maltreated \r\n\r\nand a new bug is going to have to be found and raised and fixed. Invalid calls to Hardened objects don't make it into the trunk.\r\n\r\nOf course, you don't need Harden to harden an object, but it helps.\r\n\r\n\r\nValidation\r\n----------\r\n\r\nOH yeah it validates method parameters too, so your\r\n\r\n    public virtual void DoSomething(DateTime a, DateTime b, string c, int d){ ... }\r\n    public IEnumerable<Error> ValidateDoSomething(DateTime a, DateTime b, string c) //d omitted as it doesn't need validation\r\n    {\r\n        if (a > b) yield return new Error(\"a\", \"First date must be on or before second\");\r\n        if (c.IsRudeWord()) yield return new Error(\"c\", \"Naughty naughty!\");\r\n    }\r\n\r\n\r\nand properties\r\n\r\n    public virtual string Name { get; set; }\r\n    public IEnumerable<Error> ValidateName(string value)\r\n    {\r\n        if (string.IsNullOrEmpty(value)) yield return new Error(\"c\", \"Name must be entered\");\r\n        if ((value ?? \"\").Length < 4) yield return new Error(\"c\", \"A REAL name must be entered!\");      \r\n    }\r\n\r\nCall with bad data and you get a single ValidationException with all the errors in it.\r\n\r\nSyntax\r\n------\r\n\r\nPretty simple, AllowX methods must return bool, ValidateX methods return IEnumerable<Error>\r\n\r\nIf you only want to do a property getter or setter, you can write AllowGetX or AllowSetY\r\n\r\n\r\nTo install Harden use the nuget browser or from the package manager console in VS:    \r\n    \r\n    PM> Install-Package Harden\r\n    \r\nAdvanced usage\r\n--------------\r\n\r\nI hooked the HardenInterceptor up to my IOC container, now all my entities as as hard as nails. I hardened my API, and now I don't worry about script kiddies screwing with Joe Public's data.\r\n    \r\nRemember HARD CODE IS GOOD CODE\r\n    ","tagline":"Harden your .NET objects","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}